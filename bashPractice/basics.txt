//
echo "HELLO"

//
for i in {1..100..2}
do
    echo "$i"
done

//
read name
echo "Welcome ${name}"

//
for i in {1..50}
do
echo "$i"
done

//
read x
read y
echo $((x+y))
echo $((x-y))
echo $((x*y))
echo $((x/y))

//
read x
read y
if [ $x -gt $y ]
then echo "X is greater than Y"
elif [ $x -lt $y ]
then echo "X is less than Y"
else
echo "X is equal to Y"
fi

//
read i
if [ "$i" == "y" ]||[ "$i" == "Y" ]; then
echo "YES"
else
echo "NO"
fi

//
read num
reslt=$(bc -l <(echo $num))
printf "%.3f" $reslt


//
grep -iw "the\|that\|then\|those"


//
grep '\(\d\) \?\1'
#The regexp (\d) *\1 works perfectly.
Match one digit \d and put it in a capturing group (), then 0 to any number * of spaces , then something that is the same than the first capturing group \1

//
sed 's/[Tt]hy/{&}/g'
&[ambersand] will hold the old string value and g is for globally


//
grep -w 'the'
grep -i " the "

//
grep -ivw 'that'

//
#!/bin/bash
awk '{if (NF!=4) print "Not all scores are available for " $1}'

//

#!/bin/bash
awk '{ if ($2 >= 50 && $3 >= 50 && $4 >= 50) print $1 " : Pass"; else print $1 " : Fail" }'
